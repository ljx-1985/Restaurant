好的，这是为 Cursor 项目生成的通用前端开发规范和后端开发规范。这些规范建立在之前的通用文档和编码风格规范之上，侧重于不同技术栈的开发实践和原则。

Cursor 项目通用前端开发规范

前端是用户直接交互的界面，其开发质量直接影响用户体验、性能和可维护性。本规范旨在为 Cursor 项目的前端开发提供指导原则。

1. 结构与组织

组件化 (Component-Based): 采用组件化架构，将 UI 拆分成独立、可重用、职责单一的组件。
模块化 (Modularity): 使用 ES Modules (ESM) 或项目指定的模块系统组织代码，避免全局变量污染，清晰地管理依赖。
文件组织: 采用逻辑清晰的文件和目录结构，例如按功能、按组件或按路由划分。将组件相关的样式、脚本、测试文件放在一起。
代码分离 (Separation of Concerns): 将 HTML (结构), CSS (表现), JavaScript/TypeScript (行为) 职责分离。避免在 HTML 中写大量内联样式或脚本，避免在 JS 中直接操作样式或大量生成 HTML 字符串。
2. HTML 最佳实践

语义化 (Semantic HTML): 使用恰当的 HTML5 语义化标签（如 <article>, <nav>, <aside>, <header>, <footer>, <section> 等），而不是滥用 <div>。这有助于提高可读性、可访问性和 SEO。
可访问性 (Accessibility - A11y): 遵循 Web 内容可访问性指南 (WCAG)。
使用 ARIA 属性增强语义（但尽量先使用原生语义标签）。
确保所有交互元素都可通过键盘访问和操作。
为图像提供 alt 属性。
关注色彩对比度。
精简结构: 避免不必要的嵌套层级，保持 HTML 结构扁平化。
数据属性 (data-*): 使用 data-* 属性存储与 DOM 元素相关的自定义数据，避免将数据直接存储在元素的其他属性中或解析非标准的类名。
3. CSS 最佳实践

方法论 (Methodology): 采用一种 CSS 方法论（如 BEM, SMACSS, OOCSS 或 CSS Modules/Styled Components 等）来管理类名、组织样式和提高可维护性。项目应选择并统一使用一种方法论。
模块化/组件化样式: 将样式与组件关联，减少样式之间的相互影响，避免全局样式冲突。
命名规范: 遵循项目通用的命名规范和所选 CSS 方法论的命名约定。类名应具有描述性，体现其用途或所属组件。
避免 !important: 除非在极少数需要覆盖内联样式或第三方库样式的场景，否则应避免使用 !important，它破坏了 CSS 的优先级规则，难以维护。
利用预处理器/后处理器: 如果使用 Sass, Less, PostCSS 等工具，利用其提供的变量、混合、嵌套、自动化前缀等功能提高开发效率和样式可维护性。
性能优化:
编写高效的 CSS 选择器，避免使用过于复杂的嵌套选择器或通配符选择器。
优化 CSS 文件的加载和解析（例如，按需加载，关键 CSS）。
响应式设计 (Responsive Design): 使用媒体查询 (@media) 构建响应式布局。优先使用相对单位（%, vw/vh, rem/em）而不是固定像素单位。可以采用 Mobile-First 或 Desktop-First 策略，并在项目内保持一致。
4. JavaScript / TypeScript 最佳实践

使用现代特性: 优先使用 ESNext (ES6+) 的现代 JavaScript 特性，如箭头函数、Promise, async/await, 解构、模板字面量、块级作用域 (let/const) 等。
TypeScript 使用: 如果项目使用 TypeScript，充分利用其强类型特性。
为变量、函数参数、返回值、对象属性等添加类型注解。
定义接口 (Interface) 或类型别名 (Type Alias) 来描述数据结构。
利用 TypeScript 的类型检查减少运行时错误。
异步编程: 使用 Promise 和 async/await 处理异步操作，避免回调地狱。
错误处理: 前端也需要健全的错误处理机制。
优雅地处理 API 请求错误。
捕获运行时错误，并进行适当的日志记录或向用户友好地提示。
使用 try...catch 块处理可能抛出异常的代码。
状态管理: 如果应用复杂，考虑使用成熟的状态管理库（如 Redux, Vuex, Zustand, Zustand 等）来统一管理应用的状态。
事件处理: 使用事件委托减少事件监听器的数量，优化性能。移除不再需要的事件监听器，防止内存泄漏。
DOM 操作: 尽量减少直接的 DOM 操作次数，如果需要频繁操作，考虑使用文档片段 (DocumentFragment) 或虚拟 DOM (Virtual DOM) 技术。
与后端通信: 使用统一的 API 调用模块或服务，封装请求逻辑、错误处理、认证信息传递等。
5. 前端性能优化

资源优化: 压缩和优化图片、字体文件。使用合适的图片格式（如 WebP）。
代码优化:
压缩 (Minify) 和混淆 (Uglify) JavaScript, CSS, HTML 文件。
移除死代码 (Dead Code Elimination)。
代码分割 (Code Splitting) 和按需加载 (Lazy Loading)，只加载当前页面需要的代码和资源。
网络优化: 减少 HTTP 请求数量。利用浏览器缓存。使用 CDN 加速静态资源。
渲染优化: 减少回流 (Reflow) 和重绘 (Repaint)。合理使用 CSS 属性，利用硬件加速 (如 transform, opacity)。优化列表渲染（虚拟列表）。
6. 前端测试

单元测试 (Unit Testing): 对独立的函数、组件、工具类进行单元测试，确保其逻辑正确性。
集成测试 (Integration Testing): 测试多个组件或模块之间的交互。
端到端测试 (End-to-End Testing - E2E): 模拟用户在浏览器中的完整操作流程，测试整个应用的功能是否正常。
编写可测试的代码，避免紧耦合和对外部依赖的直接依赖。
7. 依赖管理与构建

使用标准的包管理器（如 npm, yarn, pnpm）管理前端依赖。
定期更新依赖，关注安全漏洞。
使用现代化的构建工具（如 Webpack, Vite, Parcel）来打包、转译、优化前端代码。
配置开发环境的热模块替换 (HMR) 和生产环境的代码优化。
8. 部署

将前端构建产物部署到静态文件服务器或 CDN 上。
配置合适的缓存策略。
实现版本控制，确保部署新版本时用户能够加载到最新的代码，避免缓存问题。
Cursor 项目通用后端开发规范

后端负责处理业务逻辑、数据存储、安全和对外提供服务。本规范旨在为 Cursor 项目的后端开发提供指导原则。

1. 结构与组织

分层架构 (Layered Architecture): 采用清晰的分层架构，例如：
接口层/表示层 (Interface/Presentation Layer): 处理外部请求，如 API 端点、请求解析、响应格式化、认证鉴权等。
业务逻辑层/服务层 (Business Logic/Service Layer): 实现核心业务逻辑，协调各领域对象，不直接依赖接口层或数据访问层。
数据访问层 (Data Access Layer - DAL): 负责与数据库或其他数据源交互，提供数据 CURD 接口，屏蔽底层数据实现的细节。
领域模型层 (Domain Model Layer): 定义业务实体和值对象。
模块化: 将不同功能的代码组织成独立的模块、包或服务，降低耦合度。
依赖注入 (Dependency Injection - DI): 考虑使用依赖注入来管理组件之间的依赖关系，提高代码的可测试性和可维护性。
2. API 设计

RESTful 原则: 如果提供 HTTP API，应遵循 RESTful 设计原则。
资源 (Resource): 将业务概念抽象为资源（名词）。
URI: 使用清晰、层级分明的 URI 来标识资源。
HTTP 方法 (Methods): 使用标准的 HTTP 方法（GET, POST, PUT, PATCH, DELETE）来表示对资源的操作。
无状态 (Stateless): 服务器不保存客户端状态。
统一接口: 遵循统一的接口风格（请求/响应格式、错误码等）。
清晰的输入/输出: API 的输入参数和输出结构应清晰、一致且有文档。
版本控制 (Versioning): 如果 API 可能发生不兼容变更，考虑采用版本控制策略（如 URL 版本 /v1/users, Header 版本 Accept: application/json; version=1）。
使用标准状态码: 使用标准的 HTTP 状态码（如 200 OK, 201 Created, 204 No Content, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 500 Internal Server Error1 等）来表示请求的处理结果。   
1.
insightinterview.com

insightinterview.com
统一错误响应: 设计统一的错误响应格式，包含错误码、错误信息等，方便前端或其他消费者处理。
3. 数据处理与验证

输入验证 (Input Validation): 所有来自外部的输入都必须在服务器端进行严格的验证，包括来自前端、其他服务或文件的输入。不要信任客户端发送的数据。
数据序列化/反序列化: 使用合适的库或框架进行数据对象与外部格式（如 JSON, XML）之间的序列化和反序列化。
避免魔术字符串和数字: 使用常量或枚举表示有特定含义的字符串和数字。
4. 数据库交互

使用 ORM 或 Query Builder: 优先使用 ORM (Object-Relational Mapper) 或 Query Builder 进行数据库操作，减少手动编写 SQL，提高开发效率和安全性（防止 SQL 注入）。
查询优化: 关注数据库查询性能，创建合适的索引。避免 N+1 查询问题。
连接池: 使用数据库连接池管理数据库连接，提高效率和稳定性。
事务管理: 对于需要原子性操作的业务逻辑，正确使用数据库事务。
Schema 管理/迁移: 使用数据库迁移工具（如 Alembic, Django Migrations）管理数据库 schema 的变更历史。
数据安全: 敏感数据（如密码）必须加密存储（使用强大的哈希算法，加盐）。
5. 安全性最佳实践

输入验证: (再次强调) 这是最重要的安全措施之一。
认证 (Authentication): 验证用户身份。使用安全的方式存储和验证凭据（如密码哈希）。采用安全的认证机制（如 JWT, Session）。
授权 (Authorization): 验证用户是否有权限执行某个操作。在后端进行细粒度的权限检查。
防止常见攻击: 防止 SQL 注入、XSS、CSRF、SSRF、文件路径遍历等攻击。框架和库通常提供防护机制，但开发者需要正确使用。
敏感数据保护: 敏感数据加密存储，限制访问权限，日志中不记录敏感信息。
依赖安全: 定期更新后端库，关注依赖的安全漏洞。使用安全扫描工具。
速率限制 (Rate Limiting): 对 API 请求进行速率限制，防止滥用和服务拒绝攻击。
CORS (Cross-Origin Resource Sharing): 正确配置 CORS 策略，限制允许访问的域。
6. 错误处理与日志

统一错误处理: 实现全局的错误处理机制，捕获未处理的异常，并返回统一的错误响应格式。
日志记录: 使用标准的日志库进行日志记录。
定义日志级别（DEBUG, INFO, WARNING, ERROR, CRITICAL）。
记录有用的信息，包括请求 ID（用于追踪）、用户 ID、错误详情、堆栈信息等。
日志中禁止包含敏感信息（如密码、密钥、用户个人身份信息）。
配置日志的输出目标（文件、控制台、远程日志系统）。
可观测性: 考虑集成监控和告警系统。


以下原则适用于前端和后端，以及两者之间的交互：

API 契约 (API Contract): 前端和后端必须就 API 的接口、请求/响应格式、数据结构、错误码等达成一致，并记录在案（例如使用 OpenAPI/Swagger 文档）。任何一端修改 API 都必须与另一端沟通并更新文档。
端到端测试 (End-to-End Testing): 设计和实现端到端测试，覆盖用户关键操作在整个系统中的流程，验证前端、后端、数据库之间的协同工作是否正常。
配置管理: 敏感信息（如数据库密码、API 密钥）和在不同环境（开发、测试、生产）下不同的配置（如数据库地址、日志级别）应该通过环境变量或其他安全的配置管理方式进行管理，严禁将敏感信息硬编码或直接存储在代码仓库中。
错误追踪: 建立统一的错误追踪系统（如 Sentry, ELK Stack），收集前端和后端的错误信息，方便排查问题。
统一日志: 如果可能，考虑将前端的错误日志和后端的日志统一收集和管理，便于关联分析问题。